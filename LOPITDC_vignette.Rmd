---
title: "Global proteomics indicates subcellular-specific anti-ferroptotic responses to ionizing radiation"
author: "Josie A. Christopher"
date: "`r Sys.Date()`"
fontsize: 11pt 
output:
  rmdformats::robobook:
    theme: default
    fig_caption: true
    use_bookdown: true
editor_options: 
  chunk_output_type: inline
---

```{r "knitr config", cache = FALSE, include=FALSE, echo = FALSE}
require("knitr")
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(message = FALSE, warning = FALSE, dev = c("png", "pdf"), fig.path='figures/LOPIT_eFDR0.05/', dpi = 300) #Putting png first is very important for nice rendering of html!

```


# Abstract

Cells have many protective mechanisms against background levels of ionizing radiation (IR) orchestrated by molecular changes in expression, post-translational modifications and subcellular localization. Radiotherapeutic treatment in oncology attempts to overwhelm such mechanisms, but radio-resistance is an ongoing challenge. Here, global subcellular proteomics combined with Bayesian modeling identified 544 differentially localized proteins in A549 cells upon 6 Gy x-ray exposure, revealing subcellular-specific changes of proteins involved in ferroptosis, an iron-dependent cell death, suggestive of potential radio-resistance mechanisms. These observations were independent of expression changes, emphasizing the utility of global subcellular proteomics and the promising prospect of ferroptosis-inducing therapies for combating radioresistance.

<br>

# Introduction

This vignette includes the code used to analyse the subcellular proteomics work included in [Christopher et al.](https://doi.org/10.1016/j.mcpro.2024.100888).

```{r "open libraries"}

suppressMessages({
  library(tidyverse)
  library(limma)
  library(robustbase)
  library(pRoloc)
  library(camprotR) #CCP package 
  library(ggplot2)
  library(ggplot2)
  library(grid)
  library(gridExtra)
  library(tibble)
  library(RColorBrewer)
  library(cutr)
  library(umap)
  library(dplyr)
  library(colorspace)
  library(NLP)
  library(VennDiagram)
  library(knitr)
  library(png)
  library(plyr)
  library(vsn)
  library(pheatmap)
  library(clusterProfiler)
  library(ReactomePA)
  library(org.Hs.eg.db)
  library(ggrepel)
  library(bandle)
  })


source("R/Utility.R")
source("R/intersection.R")
source("./R/linear_profiles.R")
source("R/riverplot.R")

#Set colours for plots
mycol <- c("#990000", "#D55E00", "#E69F00",  "#DDCC77", "#117733", "#204f20", "#332288",  "#0170b4", "#88CCEE", "#53CAB7",  "#E18493", "#AA4499",   "#888888") 

setStockcol(mycol)

```

<br>

# Preparing LOPIT datasets

## Filtering of Proteome Discoverer data

Data loaded directly from .txt output from Proteome Discoverer (PD) 2.4 into R.
```{r "load data"}

lopit_inf <- "./raw_data/LOPIT/Mar2020_TMTPro_Multi-consensus_PSMs.txt"
crap_fasta <- "./raw_data/cRAP_FullIdentifiers.fasta"

```

cRAP fasta used to remove any common MS contaminants from the dataset. To do so, must first extract the cRAP accession IDs from the cRAP database fasta file. 
```{r "remove cRAP - labeff"}

crap.fasta <- Biostrings::fasta.index(crap_fasta, seqtype = "AA")
# Extract the non cRAP UniProt accessions associated with each cRAP protein
crap.accessions <- crap.fasta %>% 
pull(desc) %>% 
stringr::str_extract_all("(?<=\\|).*?(?=\\|)") %>% 
unlist()

```

Using the [`camprotR`](https://github.com/CambridgeCentreForProteomics/camprotR) function to parse in the PSM-level dataset. Also identifies contaminants using the cRAP accessions extracted in step above.
```{r "read psm data"}

lopit_psm <- read.delim(lopit_inf, stringsAsFactors=FALSE) %>%
  camprotR::parse_features(crap_proteins=crap.accessions)

```

View the structure of the .txt file.
```{r "view data"}

print(tibble::tibble(lopit_psm))

```

Filter any PSMs with no quantification. 
```{r "no quant filt"}

table(lopit_psm$Quan.Info) 

filt_lopit_psm <- lopit_psm[which(lopit_psm$Quan.Info != "NoQuanLabels"),]

table(filt_lopit_psm$Quan.Info) 

```

Filter any PSMs that do not have unique protein groups. 
```{r "not unique filt"}

table(filt_lopit_psm$Number.of.Protein.Groups) #all unique already

```

Remove PSMs with no accession numbers.
```{r "no acc no."}

length(which(filt_lopit_psm$Master.Protein.Accessions == " "))
# no PSMs with no accession numbers

# check this code works on an accession that does exist
length(which(filt_lopit_psm$Master.Protein.Accessions == "P16989"))

```

Double check all cRAP proteins have been removed. Within PD these proteins are also labels with a cRAP identification accession. 
```{r "double-check cRAP"}

length(grep("CRAP", filt_lopit_psm$Master.Protein.Accessions,
             ignore.case = TRUE))
# 0 as performed earlier. 

# check this code works on an accession that does exist
length(grep("P16989", filt_lopit_psm$Master.Protein.Accessions,
             ignore.case = TRUE))

```

Double-check trypsin and benzonase have been removed.
```{r "check tryp and ben"}

length(which(filt_lopit_psm$Master.Protein.Accessions == "P00761"))

length(which(filt_lopit_psm$aster.Protein.Accessions == "P13717"))

# both experimental contaminants not present.

```

Check confidence of the identified PSMs. Any filtering required? 
```{r "PSM conf"}

table(filt_lopit_psm$Confidence)

```

LOPIT-DC samples used one TMTpro 16-plex per set of replicates (i.e. 8 fractions = control, 8 fractions = IR-treated).
```{r "remove tmt channels"}

#Change the names of the spectrum files.
filt_lopit_psm$Spectrum.File[grepl("TMT_Pro_1_", filt_lopit_psm$Spectrum.File)] <- "Plex_1"
filt_lopit_psm$Spectrum.File[grepl("TMT_Pro_2_", filt_lopit_psm$Spectrum.File)] <- "Plex_2"
filt_lopit_psm$Spectrum.File[grepl("TMT_Pro_3_", filt_lopit_psm$Spectrum.File)] <- "Plex_3"


#Divide into list of controls and list of IR-treated samples.
##Control
P <- list()
for(n in seq(1:3)){
  P[[n]] <- filt_lopit_psm %>% filter(grepl(paste0("Plex_", n), filt_lopit_psm$Spectrum.File, ignore.case = F))}

names(P) <- seq(1:length(P))
```

<br>

## Creating `MSnSets` of LOPIT data

The [`pRoloc`](https://doi.org/10.12688/f1000research.10411.2) package was used for data processing, which uses `MSnSets` are utilised for data structuring. 

Divide the TMT multiplexes into control and IR-treated samples and add further information within the `pData` slot. 
```{r "divide" }

##Control
C <- list()

for(n in seq(1:3)){
  C[[n]] <- makeMSNSet(P[[n]], samples_inf = "raw_data/LOPIT/Sample_inf_control12h.txt", ab_col_ix = 2, level = "PSM", quant_name = "Abundance")}

for(n in seq(1:3)){
  pData(C[[n]])$Condition <- "Control"
}

for(n in seq(1:3)){
  pData(C[[n]])$Replicate <- n
}

pData(C[[1]]) #check pData is correctly applied.


##Treated
IR <- list()

for(n in seq(1:3)){
  IR[[n]] <- makeMSNSet(P[[n]], samples_inf = "./raw_data/LOPIT/Sample_inf_treated12h.txt", ab_col_ix = 2, level = "PSM", quant_name = "Abundance")}

for(n in seq(1:3)){
  pData(IR[[n]])$Condition <- "IR-treated"
}

for(n in seq(1:3)){
  pData(IR[[n]])$Replicate <- n
}

pData(IR[[1]]) #check pData is correctly applied.


```


Check the distribution of signal in each TMT channel. 
```{r "plot function", message=FALSE}


#Modified plotLabelQuantPSM function to add titles to plots. 
plotLabelQuantPSM <- function(obj, log=F, print=TRUE, plot_titles = x){
  tmp_df <- data.frame(exprs(obj))
  colnames(tmp_df) <- pData(obj)$Sample_name
  tmp_df[tmp_df==""] <- NA
  tmp_df <- melt(tmp_df, id.vars=NULL)
  tmp_df$value <- as.numeric(as.character(tmp_df$value))
  
  if(log){
    tmp_df$value = log(tmp_df$value,2)  
  }
  
  p <- ggplot(tmp_df) + my_theme
  
  p1 <- p + geom_boxplot(aes(variable, value)) +
    theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1)) +
    ylab("PSM intensity (log2) ") + xlab("") +
    scale_y_continuous(breaks=seq(-100,100,2)) +
    ggtitle(x)
  
  p2 <- p + geom_density(aes(value, col=variable)) +
    xlab("PSM intensity (log2) ") + ylab("Density") +
    ggtitle(x)
  
  if(print){
    print(p1)
    print(p2)
  }
  
  return(list("p1"=p1, "p2"=p2))
}

```

```{r "density plots", message=FALSE}

#Control 
x <- list()
for(n in seq(1:3)){
  x <- paste0("Control ", n)
  p <- plotLabelQuantPSM(C[[n]], log = T, plot_titles = x) 
  print(p)
}


#IR-treated 
x <- list()
for(n in seq(1:3)){
  x <- paste0("IR-treated ", n)
  p <- plotLabelQuantPSM(IR[[n]], log = T, plot_titles = x) 
  print(p)
}

```

Filter out data with low signal:noise. S:N threshold of 10 and interference/co-isolation threshold of 50.
```{r "S:N threshold"}

##Control 
for(n in seq(length(C))){
  C[[n]] <- C[[n]] %>%  filter_TMT_PSMs(inter_thresh = 50, sn_thresh = 10)
}


##IR-treated 
for(n in seq(length(IR))){
  IR[[n]] <- IR[[n]] %>%  filter_TMT_PSMs(inter_thresh = 50, sn_thresh = 10)
}


```

Still some missing values, but only small percentage of PSMs. Therefore, filter out without imputation. 
```{r "filter NAs"}

##Control
for(n in seq(1:3)){
  C[[n]] <- filterNA(C[[n]])
}

for(n in seq(1:3)){
  print(table(is.na(C[[n]]))) #check filtering has worked
}


##IR-treated
for(n in seq(1:3)){
  IR[[n]] <- filterNA(IR[[n]])
}

for(n in seq(1:3)){
  print(table(is.na(IR[[n]]))) #check filtering has worked
}



```

Combine PSMs to protein identifications. 
```{r "prot agg"}

##Control
C_prot <- lapply(C, agg_to_protein, fun = "robust")

##IR-treated
IR_prot <- lapply(IR, agg_to_protein, fun = "robust")

```

Normalisation of abundances - use sum normalisation for LOPIT data. 
```{r "pre-normalisation"}

##Control
for(n in seq(1:3)){
  meanSdPlot(C_prot[[n]])
}


##IR-treated
for(n in seq(1:3)){
  meanSdPlot(IR_prot[[n]])
}

```

```{r "normalisation"}

##Control
C_prot <-  lapply(C_prot, normalise, method = "sum")

##IR-treated
IR_prot <-  lapply(IR_prot, normalise, method = "sum")

```

```{r "post-normalisation"}

##Control
for(n in seq(1:3)){
  meanSdPlot(C_prot[[n]])
}


##IR-treated
for(n in seq(1:3)){
  meanSdPlot(IR_prot[[n]])
}


```

Annotate data sets with organelle markers from .csv file.
```{r "add markers"}

##Control
C_prot <- lapply(C_prot, addMarkers, markers = "./raw_data/final_ML.csv")


##IR-treated
IR_prot <- lapply(IR_prot, addMarkers, markers = "./raw_data/final_ML.csv")

```

<br>

## Combining LOPIT replicates

Combine replicates into one data set per condition.
```{r "combine reps"}

##Require to remove conflicting columns and sample names. 
for(n in seq(1:length(C_prot))){
  sampleNames(C_prot[[n]]) <- paste0(sampleNames(C_prot[[n]]), sep = ".", n) }

for(n in seq(1:length(IR_prot))){
  sampleNames(IR_prot[[n]]) <- paste0(sampleNames(IR_prot[[n]]), sep = ".", n) }


##Remove conflicting columns from 2 of the 3 replicates
rmfcols <- function(obj){
 fData(obj) <- fData(obj)[, -c(1: length(colnames(fData(obj))))]
 fData(obj)[,1] <- rownames(fData(obj))
 colnames(fData(obj))[1] <- "fd"
 return(obj)
} #only want to keep rownames for combining



##Control
C_prot[[2]] <- rmfcols(C_prot[[2]])
C_prot[[3]] <- rmfcols(C_prot[[3]])

C_protCom <- MSnbase::combine(C_prot[[1]], C_prot[[2]], C_prot[[3]])


##IR-treated
IR_prot[[2]] <- rmfcols(IR_prot[[2]])
IR_prot[[3]] <- rmfcols(IR_prot[[3]])

IR_protCom <- MSnbase::combine(IR_prot[[1]], IR_prot[[2]], IR_prot[[3]])


#Remove missing values 
C_protCom <- filterNA(C_protCom)
IR_protCom <- filterNA(IR_protCom)


#Check NAs and norm
summary(rowSums(exprs(C_protCom)))

```

```{r "check com norm"}

#Check normalisation 

meanSdPlot(C_protCom) ##Control

meanSdPlot(IR_protCom) ##IR-Treated

```

Ensure the proteins are shared across conditions. 
```{r "share prots"}

x <- intersect(rownames(C_protCom), rownames(IR_protCom))

C_protCom <- C_protCom[x] #subset control

IR_protCom <- IR_protCom[x] #subset treated

```

Add gene names and descriptions using SwissProt database. 
```{r "gene names"}

sp_fasta <- Biostrings::fasta.index("./raw_data/CCP_SwissProt_homo_sapiens_proteome_without_isoforms_20180409.fasta", seqtype = "AA")

# extract the UniProt accessions 
sp_accessions <- regmatches(
   sp_fasta$desc,
   gregexpr("(?<=\\|).*?(?=\\|)", sp_fasta$desc, perl = TRUE)) %>% unlist()

gene_name <- str_extract(sp_fasta$desc, "(?<=GN=)[^ ]*(?= |$)")
gene_desc <- gsub(".*HUMAN (.+) OS.*", "\\1", sp_fasta$desc)

sp_data <- cbind(sp_accessions, gene_name)
sp_data <- cbind(sp_data, gene_desc)
sp_data <- as.data.frame(sp_data)
colnames(sp_data)[1] <- "Master.Protein.Accessions" 

##Control
new_fd <- join(fData(C_protCom), sp_data)
rownames(new_fd) <- rownames(fData(C_protCom))
fData(C_protCom) <- new_fd

##IR-treated
new_fd <- join(fData(IR_protCom), sp_data)
rownames(new_fd) <- rownames(fData(IR_protCom))
fData(IR_protCom) <- new_fd

```

```{r "save com msns"}

# ##Control
# write.csv(fData(C_protCom), file = "./csv/LOPIT_eFDR0.05/C_protCom.csv")
# C_protCom %>% saveRDS(file = "./data/LOPIT_eFDR0.05/C_protCom.rds")
# 
# ##IR-treated 
# write.csv(fData(IR_protCom), file = "./csv/LOPIT_eFDR0.05/IR_protCom.csv")
# IR_protCom %>% saveRDS(file = "./data/LOPIT_eFDR0.05/IR_protCom.rds")


```

```{r "load msnsets"}

## Control 
C_reps <- readRDS("./data/LOPIT_eFDR0.05/C_prot_msnlist.rds") #replicates
C_protCom <- readRDS("./data/LOPIT_eFDR0.05/C_protCom.rds") #combined

## IR-treated 
IR_reps <- readRDS("./data/LOPIT_eFDR0.05/IR_prot_msnlist.rds") #replicates
IR_protCom <- readRDS("./data/LOPIT_eFDR0.05/IR_protCom.rds") #combined


```

<br>

# Assessing & visualising quality of the LOPIT data

## Assessing number of protein identifications

Compare the number of protein IDs between replicates and conditions. 

Between replicates - **Control samples**
```{r "venn - C reps"}


#Control
venn <- venn.diagram(
  x = list(featureNames(C_reps[[1]]), 
           featureNames(C_reps[[2]]), 
           featureNames(C_reps[[3]])),
  category.names = c("Replicate 1" , "Replicate 2 " , "Replicate 3"),
  filename = "./figures/LOPIT_eFDR0.05/venn_C_replicates.png",
  main = "Control",
  width = 5400, height = 5400,
  col=c("#440154ff", '#21908dff',  '#D6BA0D'),
  fill = c(alpha("#440154ff",0.3), alpha('#21908dff',0.3),  alpha('#D6BA0D',0.3)),
  fontfamily = "sans",
  cat.fontfamily = "sans",
  main.fontfamily = "sans",
  cat.col = c("#440154ff", '#21908dff',  '#D6BA0D'), 
  cat.cex = 3,
  main.cex = 3.5,
  cex = 3,
  cat.fontface = 2,
  cat.dist = c(0.07, 0.07, 0.03),
  sub = "",
  output = FALSE
)


## ensure PNG correctly formatted to successfully render in RMarkdown file.

# error_file <- magick::image_read("./figures/LOPIT_eFDR0.05/venn_C_replicates.png")
# right_png <- magick::image_convert(error_file, "png")
# magick::image_write(right_png, path = "./figures/LOPIT_eFDR0.05/venn_C_replicates_corr.png", format = "png")

```

```{r "venn-control", echo = FALSE, fig.cap="Shared protein IDs between control replicates"}


include_graphics("./figures/LOPIT_eFDR0.05/venn_C_replicates_corr.png")

```

Between replicates - **IR-treated samples**
```{r "venn - IR reps"}


#IR-treated
venn <- venn.diagram(
  x = list(featureNames(IR_reps[[1]]), 
           featureNames(IR_reps[[2]]), 
           featureNames(IR_reps[[3]])),
  category.names = c("Replicate 1" , "Replicate 2 " , "Replicate 3"),
  filename = "./figures/LOPIT_eFDR0.05/venn_IR_replicates.png",
  main = "IR-treated",
  width = 5400, height = 5400,
  col=c("#440154ff", '#21908dff',  '#D6BA0D'),
  fill = c(alpha("#440154ff",0.3), alpha('#21908dff',0.3),  alpha('#D6BA0D',0.3)),
  fontfamily = "sans",
  cat.fontfamily = "sans",
  main.fontfamily = "sans",
  cat.col = c("#440154ff", '#21908dff',  '#D6BA0D'), 
  cat.cex = 3,
  main.cex = 3.5,
  cex = 3,
  cat.fontface = 2,
  cat.dist = c(0.07, 0.07, 0.03),
  sub = "",
  output = FALSE
)



## ensure PNG correctly formatted to successfully render in RMarkdown file.

# error_file <- magick::image_read("./figures/LOPIT_eFDR0.05/venn_IR_replicates.png")
# right_png <- magick::image_convert(error_file, "png")
# magick::image_write(right_png, path = "./figures/LOPIT_eFDR0.05/venn_IR_replicates_corr.png", format = "png")

```

```{r "venn-treated", echo = FALSE, fig.cap="Shared protein IDs between IR-treated replicates"}


include_graphics("./figures/LOPIT_eFDR0.05/venn_IR_replicates_corr.png")

```


Overlap of protein IDs **between control and IR-treated** samples.
```{r "shared across conditions"}

#Subset shared protein IDs within control and IR-treated

x <- intersect(rownames(C_reps[[1]]), intersect(rownames(C_reps[[2]]), rownames(C_reps[[3]])))
y <- intersect(rownames(IR_reps[[1]]), intersect(rownames(IR_reps[[2]]), rownames(IR_reps[[3]])))


venn <- venn.diagram(
  x = list(x, y),
  category.names = c("Control" , "IR-treated"),
  filename = "./figures/LOPIT_eFDR0.05/control_v_treated.png",
  main = "Control vs IR-treated",
  width = 6000, height = 6000,
  col=c("#440154ff", '#21908dff'),
  fill = c(alpha("#440154ff",0.3), alpha('#21908dff',0.3)),  
  fontfamily = "sans",
  cat.fontfamily = "sans",
  main.fontfamily = "sans",
  cat.col = c("#440154ff", '#21908dff'), 
  cat.cex = 3.5,
  main.cex = 5,
  cex = 3.5,
  cat.fontface = 2,
  cat.dist = c(0.15,0.15),
  sub = "",
  output = FALSE
)


# # ensure PNG correctly formatted to successfully render in RMarkdown file.
# 
# error_file <- magick::image_read("./figures/LOPIT_eFDR0.05/control_v_treated.png")
# right_png <- magick::image_convert(error_file, "png")
# magick::image_write(right_png, path = "./figures/LOPIT_eFDR0.05/control_v_treated_corr.png", format = "png")


```

```{r "venn-conditions", echo = FALSE, fig.cap="Shared protein IDs between control vs IR-treated samples"}


include_graphics("./figures/LOPIT_eFDR0.05/control_v_treated_corr.png")

```

<br>

## Visualise correlation matrices of all fractions between between data sets

```{r, fig.height=12, fig.width=13}

c_lab <- paste0("_C_", c(1:3))
ir_lab <- paste0("_IR_", c(1:3))

c_dat <- exprs(C_protCom)
colnames(c_dat) <- paste0("C_", colnames(c_dat))

ir_dat <- exprs(IR_protCom)
colnames(ir_dat) <- paste0("IR_", colnames(ir_dat))

com_dat <- cbind(c_dat, ir_dat)

cor_mat <- cor(as.matrix(com_dat))


# Make metadata for pheatmap
c_md <- pData(C_protCom) %>% select(-Group)
rownames(c_md) <- paste0("C_", rownames(c_md))

ir_md <- pData(IR_protCom) %>% select(-Group)
rownames(ir_md) <- paste0("IR_", rownames(ir_md))

metadata <- rbind(c_md, ir_md)
metadata$Condition <- gsub("IR-treated", "IR", metadata$Condition)
colnames(metadata)[1] <- "Organelle_fraction"
# Below to get the organelle fractions in right order in the key
metadata$Organelle_fraction <- factor(metadata$Organelle_fraction, levels = metadata$Organelle_fraction[1:8])

pheatmap(cor_mat, annotation_col =metadata)

```

<br>

## Visualise correlation profiles of each replicate

```{r "linear profiles", fig.height=8, fig.width=8}

pcol <- getStockcol()[1:12] #change according to how many marker/if including unknowns
pcol <- c(pcol, "#f0f0f0")


#Control
for(n in seq(1:3)){
  p <- plot_marker_profiles(C_reps[[n]], facet_by = "markers") + scale_colour_manual(values = pcol) + scale_x_discrete(name ="Fractions", 
                    labels = pData(C_reps[[n]])$Sample_name) + ggtitle(paste0("Control: Replicate ", n))+
    theme(legend.position = "none")
  print(p)
}

#IR-treated
for(n in seq(1:3)){
  p <- plot_marker_profiles(IR_reps[[n]], facet_by = "markers") + scale_colour_manual(values = pcol) + scale_x_discrete(name ="Fractions", 
                    labels = pData(IR_reps[[n]])$Sample_name) + ggtitle(paste0("IR-treated: Replicate ", n))+
    theme(legend.position = "none")
  print(p)
}

```

<br>

## Dimension reduction visualisation of LOPIT data

### Principle component analysis (PCA) of marker proteins

```{r "plot function2"}

# These are taken from some of Lisa's code - eith some slight edits. 

prettyplots <- function(coords, object, fcol = "markers",
                       main = "", orgOrder = getMarkerClasses(object),
                       mainCol = getStockcol(), 
                       outlineCol = darken(getStockcol()), 
                       pchUn = 21, lwd = 1,
                       ...) {
  fData(object)[, "tmp"] <- fData(object)[, fcol]
  setUnknowncol(NULL)
  setUnknowncol(paste0(getUnknowncol(), 90))
  # setStockcol(NULL)
  plot2D(coords, method = "none",  methargs = list(object),
         fcol = NULL, cex = 1, pch = pchUn, grid = FALSE, main = main, 
         cex.axis = 1.5,
         cex.lab = 1.5, lwd = lwd,
         bg = getUnknowncol(), col = darken(getUnknowncol()), ...)
  cl <- getMarkerClasses(object, fcol = "tmp")
  names(cl) <- getMarkerClasses(object, fcol = "tmp")
  cl <- cl[orgOrder]
  col1 <- outlineCol
  col2 <- mainCol
  names(col1) <- cl
  names(col2) <- cl
  for (i in seq(cl)) {
    ind <- which(fData(object)[, "tmp"] == cl[i])
    points(coords[ind, ], col = col1[orgOrder][i], pch = 21, 
           bg = col2[orgOrder][i], cex = 1.5, lwd = lwd)
  }
}

prettyplot_overlay <- function(tsne_matrix, object, fcol = "markers",
                               main = "", orgOrder = getMarkerClasses(object),
                               mainCol = paste0(getStockcol(), 70),
                               outlineCol = darken(getStockcol()), ...) {
  fData(object)[, "tmp"] <- fData(object)[, fcol]
  setUnknowncol(NULL)
  setUnknowncol(paste0(getUnknowncol(), 70))
  plot2D(tsne_matrix, method = "none",  methargs = list(object),
         fcol = NULL, pch = 19, grid = FALSE, main = main,
         cex.axis = 1.5,
         cex.lab = 1.5,
         col = getUnknowncol(), ...)
  cl <- getMarkerClasses(object, fcol = "tmp")
  names(cl) <- getMarkerClasses(object, fcol = "tmp")
  cl <- cl[orgOrder]
  col1 <- outlineCol
  col2 <- mainCol
  names(col1) <- cl
  names(col2) <- cl
  for (i in seq(cl)) {
    ind <- which(fData(object)[, "tmp"] == cl[i])
    points(tsne_matrix[ind, ], col = col1[orgOrder][i], pch = 21,
           bg = col2[orgOrder][i], cex = 1.5)
  }
}

```


For individual LOPIT replicates
```{r "pca-ind", fig.height=8, fig.width=12}

par(mfrow = c(2,3))

#Control
pca <- list()
flipx <- c(F, T, F)
flipy <- c(F, T, F)

for(n in seq(1:3)){
  set.seed(7)
  pca[[n]] <- plot2D(C_reps[[n]], plot = FALSE, mirrorX = flipx[n], mirrorY = flipy[n])
  prettyplots(pca[[n]], C_reps[[n]], fcol = "markers", mainCol = paste0(getStockcol(), 80), main = paste0("Control ", n))
}


#IR-treated
pca <- list()
flipx <- c(T, T, F)
flipy <- c(T, T, F)

for(n in seq(1:3)){
  set.seed(7)
  pca[[n]] <- plot2D(IR_reps[[n]], plot = FALSE, mirrorX = flipx[n], mirrorY = flipy[n])
  prettyplots(pca[[n]], IR_reps[[n]], fcol = "markers", mainCol = paste0(getStockcol(), 80), main = paste0("IR-treated ", n))
}

```


```{r "pca-skree-ind"}

# Control
## Extract expression data, get PCA, and calculate variance for each replicate

skree_control <- list()
skree_df_c <- list()

for(n in seq(1:3)){
  skree_control[[n]] <- prcomp(exprs(C_reps[[n]]), scale = TRUE)
  skree_control[[n]] <- (skree_control[[n]]$sdev^2 / sum(skree_control[[n]]$sdev^2))*100
  skree_df_c[[n]] <- as.data.frame(skree_control[[n]])
  skree_df_c[[n]]$samp <- paste0("control", n)
  skree_df_c[[n]]$PC <- seq(1:8)
  colnames(skree_df_c[[n]])[1] <- "var"
}

skree_df_c <- do.call(rbind, skree_df_c)

# IR-treatment
## Extract expression data, get PCA, and calculate variance for each replicate

skree_ir <- list()
skree_df_ir <- list()

for(n in seq(1:3)){
  skree_ir[[n]] <- prcomp(exprs(IR_reps[[n]]), scale = TRUE)
  skree_ir[[n]] <- (skree_ir[[n]]$sdev^2 / sum(skree_ir[[n]]$sdev^2))*100
  skree_df_ir[[n]] <- as.data.frame(skree_ir[[n]])
  skree_df_ir[[n]]$samp <- paste0("IR-treated", n)
  skree_df_ir[[n]]$PC <- seq(1:8)
  colnames(skree_df_ir[[n]])[1] <- "var"
}

skree_df_ir <- do.call(rbind, skree_df_ir)

# Plot 
skree_df <- rbind(skree_df_c, skree_df_ir)

ggplot(skree_df) +
  geom_line(aes(x = PC, y = var, color = samp), size = 1.5, alpha = 0.5) +
  scale_color_manual(values = mycol[1:6]) +
  ylab("Explained variance (%)") +
  xlab("Principle component") +
  theme_bw() + 
  theme(legend.title = element_blank(),
        legend.text = element_text(size = 15),
        axis.title = element_text(size = 15),
        axis.text = element_text(size = 12))


```


Combined LOPIT plots
```{r combined-pca, fig.height=4, fig.width=12}

par(mfrow = c(1,3))

pca <- plot2D(C_protCom, plot = FALSE) #, mirrorX = flipx[n], mirrorY = flipy[n])
prettyplots(pca, C_protCom, fcol = "markers", mainCol = paste0(getStockcol(), 80), main ="Control")


pca <- plot2D(IR_protCom, plot = FALSE) #, mirrorX = flipx[n], mirrorY = flipy[n])
prettyplots(pca, IR_protCom, fcol = "markers", mainCol = paste0(getStockcol(), 80), main ="IR-treated")

plot.new()
addLegend(C_protCom, fcol = "markers", "left", cex = 1.5)
```

```{r "pca-skree-comb"}

skree_control <- prcomp(exprs(C_protCom), scale = TRUE)
skree_control <- (skree_control$sdev^2 / sum(skree_control$sdev^2))*100
skree_control <- data.frame("var" = skree_control, "samp" = "control", "PC" = seq(1:24))


skree_ir <- prcomp(exprs(IR_protCom), scale = TRUE)
skree_ir <- (skree_ir$sdev^2 / sum(skree_ir$sdev^2))*100
skree_ir <- data.frame("var" = skree_ir, "samp" = "IR-treated", "PC" = seq(1:24))

skree_df <- rbind(skree_control, skree_ir)


ggplot(skree_df) +
  geom_line(aes(x = PC, y = var, color = samp), size = 1.5, alpha = 0.5) +
  scale_color_manual(values = mycol[c(1,6)]) +
  ylab("Explained variance (%)") +
  xlab("Principle component") +
  theme_bw()


```




### t-distributed stochastic neighbor embedding (t-SNE) of marker proteins

<!-- For individual LOPIT replicates -->
<!-- ```{r "tsne-ind"} -->

<!-- par(mfrow = c(2,3)) -->

<!-- #Control -->
<!-- tsne_c <- list() -->
<!-- flipx <- c(F, T, F) -->
<!-- flipy <- c(T, F, F) -->

<!-- for(n in seq(1:3)){ -->
<!--   set.seed(7) -->
<!--   tsne_c[[n]] <- plot2D(C_reps[[n]], plot = FALSE, method = "t-SNE", mirrorX = flipx[n], mirrorY = flipy[n]) -->
<!--   prettyplots(tsne_c[[n]], C_reps[[n]], fcol = "markers", mainCol = paste0(getStockcol(), 80), main = paste0("Control ", n)) -->
<!-- } -->


<!-- #IR-treated -->
<!-- tsne_ir <- list() -->
<!-- flipx <- c(F, F, F) -->
<!-- flipy <- c(F, F, F) -->

<!-- for(n in seq(1:3)){ -->
<!--   set.seed(7) -->
<!--   tsne_ir[[n]] <- plot2D(IR_reps[[n]], plot = FALSE,  method = "t-SNE", mirrorX = flipx[n], mirrorY = flipy[n]) -->
<!--   prettyplots(tsne_ir[[n]], IR_reps[[n]], fcol = "markers", mainCol = paste0(getStockcol(), 80), main = paste0("IR-treated ", n)) -->
<!-- } -->

<!-- ``` -->


Combined LOPIT plots
```{r combined-tsne, fig.height=4, fig.width=12}

par(mfrow = c(1,3))

set.seed(7)
tsne_c <- plot2D(C_protCom, plot = FALSE, method = "t-SNE") #, mirrorX = flipx[n], mirrorY = flipy[n])
prettyplots(tsne_c, C_protCom, fcol = "markers", mainCol = paste0(getStockcol(), 80), main ="Control")

set.seed(7)
tsne_ir <- plot2D(IR_protCom, plot = FALSE, method = "t-SNE") #, mirrorX = flipx[n], mirrorY = flipy[n])
prettyplots(tsne_ir, IR_protCom, fcol = "markers", mainCol = paste0(getStockcol(), 80), main ="IR-treated")

plot.new()
addLegend(C_protCom, fcol = "markers", "left", cex = 1.5)

```






# BANDLE analysis

[BANDLE](https://doi.org/10.1038/s41467-022-33570-9) was used to perform the subcellular proteomics analysis to classify proteins to distinct subcellular locations and assess the likihood they were differentially localising in response to treatment. 

<br>

## BANDLE optimisation

Optimisation of the hyperparameters was performed. There are three parameters: (1) the prior, (2) length-scale amplitude and (3) standard deviation parameters, as mentioned in the [BANDLE vignette](https://www.bioconductor.org/packages//release/bioc/vignettes/bandle/inst/doc/v01-getting-started.html). For this analysis, several different values for the third parameter (standard deviation) were tested: 250, 200, 150 and 100. This effects the "looseness" of the fit. Then the estimated FDR and convergence were assessed. The default values were used for the prior and length-scale amplitude, 10 and 60, respectively. 


**Convergence plots**
```{r "convergence_250gp"}


load("./data/LOPIT/bandleres_12hr.rda")


par(mfrow = c(2, 2))
out <- plotConvergence(bandleres_12hr) 

res <- summaries(bandleres_12hr)
pe1 <- posteriorEstimates(res[[1]])
diffloc_probs <- pe1$bandle.differential.localisation


df_efdr <- data.frame("eFDR" = EFDR(diffloc_probs, threshold = 0.95), "GP_param" = "250")


```

```{r "convergence_200gp"}

rm(bandleres_12hr)

load("./data/LOPIT/bandleres_12hr_200gp.rda")

par(mfrow = c(2, 2))
out <- plotConvergence(bandleres_12hr)


#bandleres_12hr <- bandleProcess(bandleres_12hr)
#save(bandleres_12hr, file = "./data/LOPIT/bandleres_12hr_200gp.rda")

res <- summaries(bandleres_12hr)
pe1 <- posteriorEstimates(res[[1]])
diffloc_probs <- pe1$bandle.differential.localisation

gp200 <- data.frame("eFDR" = EFDR(diffloc_probs, threshold = 0.95), "GP_param" = "200")

df_efdr <- rbind(df_efdr, gp200)



```

```{r "convergence_150gp"}

rm(bandleres_12hr)

load("./data/LOPIT/bandleres_12hr_150gp.rda")

par(mfrow = c(2, 2))
out <- plotConvergence(bandleres_12hr)


# bandleres_12hr <- bandleProcess(bandleres_12hr)
# save(bandleres_12hr, file = "./data/LOPIT/bandleres_12hr_150gp.rda")

res <- summaries(bandleres_12hr)
pe1 <- posteriorEstimates(res[[1]])
diffloc_probs <- pe1$bandle.differential.localisation

gp150 <- data.frame("eFDR" = EFDR(diffloc_probs, threshold = 0.95), "GP_param" = "150")

df_efdr <- rbind(df_efdr, gp150)



```

```{r "convergence_100gp"}

rm(bandleres_12hr)

load("./data/LOPIT/bandleres_12hr_100gp.rda")

par(mfrow = c(2, 2))
out <- plotConvergence(bandleres_12hr)


# bandleres_12hr <- bandleProcess(bandleres_12hr)
# save(bandleres_12hr, file = "./data/LOPIT/bandleres_12hr_100gp.rda")

res <- summaries(bandleres_12hr)
pe1 <- posteriorEstimates(res[[1]])
diffloc_probs <- pe1$bandle.differential.localisation

# trtfdr <- inverse(EFDR(diffloc_probs, threshold = 0.9))

gp100 <- data.frame("eFDR" = EFDR(diffloc_probs, threshold = 0.95), "GP_param" = "100")

df_efdr <- rbind(df_efdr, gp100)



```

**EFDR plots**

Plot the estimated FDR (eFDR) for each set of hyper-parameter that was tried. The lower the setting for the third parameter in the `pc_prior` object (responsible for the standard deviation settings) the less shrinkage there is and the more realistic the FDR score becomes (i.e. ~0.4% rather than ~0.1%). This may reduce the over-fitting found in previous analysis using the default parameters. 

The below plot is when setting the threshold of 0.95 on the bandle params file. 
```{r efdr}


ggplot(df_efdr, aes(x = GP_param, y = eFDR*100, group = 1), size = 1.5, alpha = 0.5) +
  geom_point() +
    geom_line() +
  scale_color_manual(values = mycol[1]) +
  ylab("eFDR (%)") +
  xlab("3rd parameter in pc_prior (SD)") +
  theme_bw()


```

These values still seem quite low. Computationally taxing to keep re-running bandle with different parameters. Therefore, took the bandle params object that was run using the third GP parameter that was set to 100 and then tested different thresholds. The polynomial regression model was then used to predict the threshold for BANDLE differential localisation score threshold to give ~5% FDR. 
```{r efdr-100gp}

gp <- c(seq(1:100)/100)
gp100_efdr <- list()

for(n in 1:length(gp)) {
  
  gp100_efdr[[n]] <- data.frame("eFDR" = EFDR(diffloc_probs, threshold = gp[n]), "threshold" = gp[n])

}

gp100_efdr <- do.call(rbind, gp100_efdr)


ggplot(na.omit(gp100_efdr), aes(x = threshold, y = eFDR*100, group = 1), size = 1.5, alpha = 0.5) +
  geom_point() +
    geom_smooth(method = "lm", formula = y ~ poly(x,5, raw = T)) +
  scale_color_manual(values = mycol[1]) +
  ylab("eFDR (%)") +
  xlab("3rd parameter in pc_prior (SD)") +
  theme_bw()


# Perform polynomial regression (as used to create the line in plot above)
my_mod <- lm(threshold ~ poly(eFDR, 5),        # Estimate polynomial regression model
             data = na.omit(gp100_efdr))

summary(my_mod) 


# Now use the model to predict which threshold to use to have ~5% FDR.
bandle_threshold <- predict(my_mod, data.frame(eFDR = c(0.05)))

print(bandle_threshold)

```

While this seems like a lower threshold - this was to limit overfitting of the classifications in Bandle. 
```{r}
C_list <- list()
C_list[[1]] <- C_protCom[,1:8]
C_list[[2]] <- C_protCom[,9:16]
C_list[[3]] <- C_protCom[,17:24]

IR_list <- list()
IR_list[[1]] <- IR_protCom[,1:8]
IR_list[[2]] <- IR_protCom[,9:16]
IR_list[[3]] <- IR_protCom[,17:24]

#Then combine lists 
all_list <- c(C_list, IR_list)

```


The fit for these profiles seems reasonable - not too lax or too fitting. 
```{r "gp-param-plots", fig.width= 12, fig.height= 10}

K <- length(getMarkerClasses(all_list[[1]]))
pc_prior <- matrix(NA, ncol = 3, K)
pc_prior[seq.int(1:K), ] <- matrix(rep(c(10, 60, 100), #These numbers can be customised e.g. to shrink error bars (if needed). 
                                       each = K), ncol = 3)

par(mfrow = c(3,4))
gpParams <- lapply(all_list, function(x) fitGPmaternPC(x, hyppar = pc_prior))
plotGPmatern(all_list[[1]], params = gpParams[[1]])
dev.off()

dirPrior = diag(rep(1, K)) + matrix(0.001, nrow = K, ncol = K)
predDirPrior <- prior_pred_dir(object = all_list[[3]],
                               dirPrior = dirPrior,
                               q = 40)

hist(predDirPrior$priornotAlloc, col = getStockcol()[1])

#save these for future use - as can take a bit of time to process/ensure any customised parametrs are saved. 
# save(pc_prior, file = "rData/pc_prior.rda")
# save(gpParams, file = "rData/gpParams.rda")
```

```{r "barplots-all.alloc"}

pe1 <- summaries(bandleres_12hr)[[1]]@posteriorEstimates

pe1 <- summaries(bandleres_12hr)[[1]]@posteriorEstimates
#barplot(table(pe1$bandle.allocation), col = "steelblue", las = 2, main = "Bandle Allocations: Control")



pe2 <- summaries(bandleres_12hr)[[2]]@posteriorEstimates

pe2 <- summaries(bandleres_12hr)[[2]]@posteriorEstimates
#barplot(table(pe2$bandle.allocation), col = "salmon", las = 2, main = "Bandle Allocations: IR-treated")


#could make combined barplots?
df1 <- melt(table(pe1$bandle.allocation))
df1$group <- "Control"

df2 <- melt(table(pe2$bandle.allocation))
df2$group <- "IR-treated"

df <- rbind(df1, df2)

head(df)
tail(df)

ggplot(data=df, aes(x=Var1, y=value, fill=group)) +
geom_bar(stat="identity", position=position_dodge()) + scale_fill_manual(values=mycol[c(1,3)]) +
  scale_x_discrete(guide = guide_axis(angle = 45)) + xlab("Subcellular Classification") + ylab("Number of proteins classified") + labs(fill = "") +
  theme_bw()

```



We can append the results to our original `MSnSet` datasets using the 
`bandlePredict` function. Assessing the S-plot shows a more realistic distribution - i.e. the scores aren't as binary as the previous bandle analyses using the default parameters. Majority of the scores are 0, which suggests more proteins are static rather than dynamic. 

```{r bandpred, fig.height=6, fig.width=6}

control <- all_list[1:3]
treatment <- all_list[4:6]

xx <- bandlePredict(control, 
                    treatment, 
                    params = bandleres_12hr, 
                    fcol = "markers")
res_control <- xx[[1]]
res_treatment <- xx[[2]]

# x <- fData(res_control[[1]])[which(fData(res_control[[1]])$bandle.differential.localisation  >= 0.95), ]
# write.csv(x, "./csv/sigdl_12hr.csv")

plot(diffloc_probs[order(diffloc_probs, decreasing = TRUE)],
     col = getStockcol()[3], pch = 19, ylab = "Localization probability",
     xlab = "Ranked proteins", main = "Differential localisation rank plot")

# write.csv(fData(res_control[[1]]), "./csv/LOPIT_eFDR0.05/BANDLE_scores_control.csv")
# write.csv(fData(res_treatment[[1]]), "./csv/LOPIT_eFDR0.05/BANDLE_scores_treatment.csv")

```

Merge bandle information into MSnSets. 
```{r}
bandcom <- bandlePredict(list(C_protCom), list(IR_protCom), bandleres_12hr, fcol = "markers")

#Control
fData(C_protCom)$all.alloc <- fData(C_protCom)$markers #add markers to new column

fData(C_protCom)$all.alloc[match(rownames(pe1), rownames(fData(C_protCom)))] <- pe1$bandle.allocation #Match accessions and substitute the non-markers to bandle allocations

##For rest of bandle data the merge function can be use with all = TRUE to make sure all rows are kept. 
df1 <- rownames_to_column(fData(C_protCom))
df2 <- rownames_to_column(as.data.frame(pe1))
fd <- left_join(df1, df2)
fd <- column_to_rownames(fd, var = "rowname")
fData(C_protCom) <- fd


#IR-treated
fData(IR_protCom)$all.alloc <- fData(IR_protCom)$markers #add markers to new column

fData(IR_protCom)$all.alloc[match(rownames(pe2), rownames(fData(IR_protCom)))] <- pe2$bandle.allocation #Match accessions and substitute the non-markers to bandle allocations

##For rest of bandle data the merge function can be use with all = TRUE to make sure all rows are kept. 
df1 <- rownames_to_column(fData(IR_protCom))
df2 <- rownames_to_column(as.data.frame(pe2))
fd <- left_join(df1, df2)
fd <- column_to_rownames(fd, var = "rowname")
fData(IR_protCom) <- fd


```

<br>

## Add column in MSnset without outliers

Bandle creates an outlier column, which can be used to filter unreliable allocations.
Outlier probability is on a scale of 0 to 1. Set a threshold of 0.05 (or 5% chance the allocation is an outlier). Do this in a new, separate column. Could still be a gentle slope if paramters were optimised further 
```{r}
#Control
fData(C_protCom)$alloc.noOut <- fData(C_protCom)$all.alloc
fData(C_protCom)$alloc.noOut[fData(C_protCom)$bandle.outlier > 0.05] <- "unknown"
no_out_C <- fData(C_protCom)[which(fData(C_protCom)$bandle.outlier < 0.05),]
dim(no_out_C)[1] # Though these may include the markers?
no_out_C <- no_out_C[which(no_out_C$markers == "unknown"),]
dim(no_out_C)[1] # Same number as the original script also filters out markers. 


#IR-treated
fData(IR_protCom)$alloc.noOut <- fData(IR_protCom)$all.alloc
fData(IR_protCom)$alloc.noOut[fData(IR_protCom)$bandle.outlier > 0.05] <- "unknown"
no_out_IR <- fData(IR_protCom)[which(fData(IR_protCom)$bandle.outlier < 0.05),]
dim(no_out_IR)[1] # Though these may include the markers?
no_out_IR <- no_out_IR[which(no_out_IR$markers == "unknown"),]
dim(no_out_IR)[1] # Same number as the original script also filters out markers. 


# save(C_protCom, file = "data/LOPIT_eFDR0.05/C_protCom_BANDLE_12hr.rda")
# save(IR_protCom, file = "data/LOPIT_eFDR0.05/IR_protCom_BANDLE_12hr.rda")

```

<br>

## Ellipses plots
Inner ellipses = 0.99 probability of those proteins being allocated to that subcellular compartment, 2nd inner ellipses = 0.95, from then on decrease by 0.05.
```{r, "ellipses-plots", fig.width= 9, fig.height= 7.5 }

bandle::spatial2D(C_protCom, bandleres_12hr) + labs(colour = "Subcellular compartment")

bandle::spatial2D(IR_protCom, bandleres_12hr) + labs(colour = "Subcellular compartment")
```

<br>

## Plot BANDLE annotations 

```{r "pca-BANDLE-all.alloc", fig.height=4, fig.width=12}

par(mfrow = c(1,3))
 
#Control
prettyplots(tsne_c, C_protCom, fcol = "alloc.noOut", mainCol = paste0(getStockcol(), 80), main = "Control: combined replicates")


#IR-treated
prettyplots(tsne_ir, IR_protCom, fcol = "alloc.noOut", mainCol = paste0(getStockcol(), 80), main = "IR-treated: combined replicates")

plot.new()
addLegend(C_protCom, fcol = "all.alloc", "left", cex = 2)

```

<br>

# Localisation probabilities/heatmaps 
```{r "heatmap-1", fig.width = 10, fig.height= 10}
library(pheatmap)
library(viridis)
pheatmap(summaries(bandleres_12hr)[[1]]@bandle.joint, cluster_cols = FALSE, color = viridis(n = 25))

```


```{r "heatmap-2", fig.width = 10, fig.height= 10 }

## All allocations
.IR <- IR_protCom
.IR <- updateFvarLabels(.IR, "IR-treated")
cmb <- MSnbase::combine(C_protCom, .IR)  # now combine all results

df_all <- compareDatasets(cmb, 
                          fcol1 = "all.alloc",
                          fcol2 = "all.alloc.IR-treated")
ggheatmap(df_all, title = "BANDLE locations between conditions")+
  xlab("test")


## No outliers
df_all <- compareDatasets(cmb, 
                          fcol1 = "alloc.noOut",
                          fcol2 = "alloc.noOut.IR-treated")
ggheatmap(df_all, title = "BANDLE locations between conditions")




```

<br>

# Alluvial (river) & Circos plots for all translocating proteins 
```{r "alluvial-plot", fig.height=12, fig.width=10}

#Subset those that are thought to translocate 
ct <- C_protCom[which(fData(C_protCom)$bandle.differential.localisation >= bandle_threshold), ]
irt <- IR_protCom[which(fData(IR_protCom)$bandle.differential.localisation >= bandle_threshold), ]


data <- commonFeatureNames(ct, irt)
c <- data[[1]]
ir <- data[[2]]
#orgs <- union(unique(fData(c)$alloc.noOut), unique(fData(ir)$alloc.noOut))
orgs <- unique(fData(IR_protCom)$alloc.noOut)
orgs <- sort(orgs)
## set organelle colours
mycol <- getStockcol()#[-13]
mycol <- c(mycol, getUnknowncol())
#mycol <- c(getStockcol()[1:(length(orgs)-1)], getUnknowncol())

scales::show_col(mycol)
colscheme <- setNames(mycol, orgs)  # check levels consistent 

## plot all proteins
thp_alluvial <- riverplot(c, ir, 
                          fcol1 = "alloc.noOut",
                          fcol2 = "alloc.noOut",
                          mrkCol1 = "markers",
                          mrkCol2 = "markers",
                          onlyMovers = T,
                          cols = colscheme,
                          labels = F)
thp_alluvial + ggtitle("All proteins")


##remove unknowns
c <- C_protCom[which(fData(C_protCom)$alloc.noOut != "unknown"),] 
ir <- IR_protCom[which(fData(IR_protCom)$alloc.noOut != "unknown"),] 


data <- commonFeatureNames(c, ir)
c <- data[[1]]
ir <- data[[2]]
orgs <- c(union(getMarkerClasses(c), getMarkerClasses(ir)), "unknown")
## set organelle colours
mycol <- c(getStockcol()[1:(length(orgs)-1)], getUnknowncol())
scales::show_col(mycol)
(colscheme <- setNames(mycol, orgs))  # check levels consistent 




## plot all proteins
thp_alluvial <- riverplot(c, ir, 
                          fcol1 = "all.alloc",
                          fcol2 = "all.alloc",
                          mrkCol1 = "markers",
                          mrkCol2 = "markers",
                          onlyMovers = TRUE,
                          cols = colscheme,
                          labels = F)
thp_alluvial + ggtitle("Removing unknowns as translocations")


#Assess the allocations before filtering with outlier values
data <- commonFeatureNames(C_protCom, IR_protCom)
c <- data[[1]]
ir <- data[[2]]
orgs <- c(union(getMarkerClasses(c), getMarkerClasses(ir)), "unknown")
## set organelle colours
mycol <- c(getStockcol()[1:(length(orgs)-1)], getUnknowncol())
scales::show_col(mycol)
(colscheme <- setNames(mycol, orgs))  # check levels consistent 

## plot all proteins
thp_alluvial <- riverplot(c, ir, 
                          fcol1 = "all.alloc",
                          fcol2 = "all.alloc",
                          mrkCol1 = "markers",
                          mrkCol2 = "markers",
                          onlyMovers = TRUE,
                          cols = colscheme,
                          labels = F)
thp_alluvial + ggtitle("Assessing the localisations of all BANDLE classification (before accounting outliers)")
```

```{r diffloc-table, fig.height = 6, fig.width=6.5}

#Info for adding labels for protein numbers - but would need to add in Illustrator.
df <- makedf(c, ir, 
      fcol1 = "all.alloc",
      fcol2 = "all.alloc",
      mrkCol1 = "markers",
      mrkCol2 = "markers",
      onlyMovers = T)

# print(df)

# Add NA data to make ggplot figure 
na_data <- data.frame(x = orgs[-13], y = orgs[-13], count = NA)
df <- rbind(df, na_data)

ggplot(df, aes(x = x, y = y, fill = as.numeric(count)))+
  geom_tile()+
  geom_text(data = df %>% filter(count != 0, count < 50), aes(x, y, label= count), colour = "black", check_overlap = TRUE, size = 5)  +
    geom_text(data = df %>% filter(count != 0, count >= 50), aes(x, y, label= count), colour = "white", check_overlap = TRUE, size = 5)  +
  scale_fill_gradient(low = "#F7FCFD", high = "#00441B", na.value = "grey") +
  xlab("Control")+
  ylab("IR-treated")+
  theme_light() +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45,hjust=0.95, size = 12),
        axis.text.y = element_text(size = 12),
        axis.title = element_text(size = 20))


```


<!-- ```{r "circos-plots", fig.width=10, fig.height=10} -->
<!-- source("Source_code-Lisa/circosplot.R") -->
<!-- # https://github.com/CambridgeCentreForProteomics/thp-lopit-2021/blob/main/R/circos.R -->


<!-- ## get data -->
<!-- data <- commonFeatureNames(C_protCom_shared, IR_protCom_shared) -->
<!-- c <- data[[1]] -->
<!-- ir <- data[[2]] -->

<!-- ## generate my colour scheme - same as alluvial -->


<!-- ## get indices of translocating proteins -->
<!-- tl <- which(fData(C_protCom_shared)[, "alloc.noOut"] != fData(IR_protCom_shared)[, "alloc.noOut"]) -->

<!-- ## set circos plot parameters -->
<!-- par(mar = c(4, 5, 5, 5), cex = .5, mfrow = c(1,1)) -->
<!-- circos.clear() -->
<!-- circos.par(gap.degree = 3) -->

<!-- ## plot circos -with labels -->
<!-- customChord(c[tl, ], ir[tl, ],  -->
<!--             cols = colscheme, -->
<!--             fcol1 = "alloc.noOut", -->
<!--             fcol2 = "alloc.noOut", -->
<!--             diffHeight  = -0.02,  -->
<!--             transparency = 0.3,  -->
<!--             link.sort = TRUE, -->
<!--             labels = TRUE) #Edit labels in illustrator - as difficult to place.  -->


<!-- ## plot circos - without labels -->
<!-- customChord(c[tl, ], ir[tl, ],  -->
<!--             cols = colscheme, -->
<!--             fcol1 = "alloc.noOut", -->
<!--             fcol2 = "alloc.noOut", -->
<!--             diffHeight  = -0.02,  -->
<!--             transparency = 0.3,  -->
<!--             link.sort = TRUE, -->
<!--             labels = FALSE) #Edit labels in illustrator - as difficult to place.  -->



<!-- ``` -->

## GO enrichment of LOPIT data

Perform GO:BP enrichment on all proteins that have moved. 
 
```{r GO-all, fig.height=4, fig.width=7}

ct <- rownames(C_protCom[which(fData(C_protCom)$bandle.differential.localisation >= bandle_threshold), ])
irt <- rownames(IR_protCom[which(fData(IR_protCom)$bandle.differential.localisation >= bandle_threshold), ])
comp_l <- intersect(ct, irt)

# extract all gene names from df.combi to get the background list
allg <- rownames(C_protCom)


# convert to ENTREZID - will say ~50% not mapped but these are duplicates.
# int_all <- bitr(int_all, fromType = "SYMBOL",toType = "ENTREZID", OrgDb = "org.Hs.eg.db")
comp_l <- bitr(comp_l, fromType = "UNIPROT",toType = "ENTREZID", OrgDb = "org.Hs.eg.db")
geneList <- bitr(allg, fromType = "UNIPROT",toType = "ENTREZID", OrgDb = "org.Hs.eg.db")


bp_go <- enrichGO(gene = comp_l$ENTREZID,
                  universe      = geneList$ENTREZID,
                  OrgDb         = org.Hs.eg.db,
                  keyType       = "ENTREZID",
                  ont           = "BP",
                  pAdjustMethod = "BH",
                  pvalueCutoff  = 0.05,
                  qvalueCutoff  = 0.05,
                  readable      = TRUE)
 
bp_go <- clusterProfiler::simplify(bp_go, cutoff = 0.6, by = "p.adjust", select_fun = min) # try to remove redundant terms (not that effective)
res <- bp_go@result


# Filter the terms want to look at - i.e. "significant" in at least one of the samples.
filt <- res %>% filter(res$pvalue < 0.05)


filt $log_p.adjust <- -log10(filt$p.adjust)
filt$log_p.adjust[is.na(filt$log_p.adjust)] <- 0
filt  <- filt[order(filt$log_p.adjust, decreasing = F),]
filt$Description <- factor(filt$Description, levels = filt$Description[!duplicated(filt$Description)])

filt$log_p.adjust[filt$log_p.adjust == 0] <- NA

filt  %>%
  ggplot(aes(x = Description, y = log_p.adjust)) +
  geom_segment( aes(x=Description ,xend=Description, y=0, yend=log_p.adjust), color="grey") +
  geom_point(size = 4, color = "#66C2A4", alpha = 0.8)+
  #geom_bar(stat = "identity", alpha = 0.5) +
  coord_flip() +
  xlab("Enriched GO:BP term") + ylab("-log10(adjusted p-value)")  +
  #facet_grid(Method~.)+
  #guides(color = "none") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1.01),
        legend.title = element_blank(),
        legend.position = "top" 
        )


```

## REACTOME enrichment of LOPIT data

Perform REACTOME enrichment on all proteins that have moved. This may be more informative than the gene ontology terms. 

```{r REACT-all, fig.height=7, fig.width=10}

react <- enrichPathway(gene=comp_l$ENTREZID, 
                            universe = geneList$ENTREZID, 
                            pvalueCutoff = 0.01, 
                            readable=TRUE)

res <- react@result

# Filter the terms want to look at - i.e. "significant" in at least one of the samples.
filt <- res %>% filter(res$pvalue < 0.05)


filt $log_p.adjust <- -log10(filt$p.adjust)
filt$log_p.adjust[is.na(filt$log_p.adjust)] <- 0
filt  <- filt[order(filt$log_p.adjust, decreasing = F),]
filt$Description <- factor(filt$Description, levels = filt$Description[!duplicated(filt$Description)])

filt$log_p.adjust[filt$log_p.adjust == 0] <- NA

filt  %>%
  ggplot(aes(x = Description, y = log_p.adjust)) +
  geom_segment( aes(x=Description ,xend=Description, y=0, yend=log_p.adjust), color="grey") +
  geom_point(size = 4, color = "#66C2A4", alpha = 0.8)+
  #geom_bar(stat = "identity", alpha = 0.5) +
  coord_flip() +
  xlab("Enriched REACTOME term") + ylab("-log10(adjusted p-value)")  +
  #facet_grid(Method~.)+
  #guides(color = "none") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1.01),
        legend.title = element_blank(),
        legend.position = "top" 
        )

# write.csv(filt, "./csv/LOPIT_eFDR0.05/reactome_results.csv")


# Added column manually to remove redundant terms. 
filt <- read.csv("./csv/LOPIT_eFDR0.05/reactome_results.csv")

#filt <- filt %>% filter(filt$Redundant == F)
filt  <- filt[order(filt$log_p.adjust, decreasing = F),]
filt$Description <- factor(filt$Description, levels = filt$Description[!duplicated(filt$Description)])

filt  %>%
  ggplot(aes(x = Description, y = log_p.adjust)) +
  geom_segment( aes(x=Description ,xend=Description, y=0, yend=log_p.adjust), color="grey") +
  geom_point(size = 4, color = "#66C2A4", alpha = 0.8)+
  #geom_bar(stat = "identity", alpha = 0.5) +
  coord_flip() +
  xlab("Enriched REACTOME term") + ylab("-log10(adjusted p-value)")  +
  #facet_grid(Method~.)+
  #guides(color = "none") +
  theme_classic() +
  theme(axis.text = element_text(size = 15),
        axis.title = element_text(size = 20),
        legend.title = element_blank(),
        legend.position = "top" 
        )

```

## Compare LOPIT versus shotgun data

```{r}

# ### Save proteins that have moved to csv to compare with the total proteome data
# 
# write.csv(fData(C_protCom)[which(fData(C_protCom)$bandle.differential.localisation >= bandle_threshold),], "./csv/LOPIT_eFDR0.05/diffloc_hits.csv")


```

```{r}
#load lopit hits
lopit_hit <- read.csv("./csv/LOPIT_eFDR0.05/diffloc_hits.csv")$X

#load shotgun hits
sg_hits <- read.csv("./data/total_proteome/Limma_results_limnorm.csv")
sg_hits <- sg_hits[grepl("Upregulated|Downregulated", sg_hits$Significance),]

#changes in both
shared_hits <- intersect(lopit_hit, sg_hits$Row.names) 

shared_hits <- sg_hits[sg_hits$Row.names %in% lopit_hit,]

# write.csv(shared_hits, file = "./csv/shared_hits.csv")

```

<br>

# Plot some of the shared GO terms between LOPIT and total proteome

"Retinoid metabolism and transport"
```{r retinoid, fig.height=5, fig.width=15}

tp_res <- read.csv("./csv/total_proteome/reactome_results_edited.csv")

total <- tp_res[which(tp_res$Description == "Retinoid metabolism and transport"),]$geneID %>% strsplit(split = "\\/") %>% unlist()

lopit_res <- read.csv("./csv/LOPIT_eFDR0.05/reactome_results.csv")

lopit <- lopit_res[which(lopit_res$Description == "Retinoid metabolism and transport"),]$geneID %>% strsplit(split = "\\/") %>% unlist()

both <- intersect(lopit, total)


# Make extra tsne object for labelling - need row names as gene names 
points_c <- tsne_c
points_ir <- tsne_ir
rownames(points_c) <- fData(C_protCom)$gene_name
rownames(points_ir) <- fData(IR_protCom)$gene_name

par(mfrow = c(1,3))
prettyplot_overlay(tsne_c, C_protCom, fcol = "alloc.noOut", main = "Control", mainCol = paste0(darken(mycol), 30),  outlineCol = paste0(lighten(mycol), 30))
text(points_c[total, 1], points_c[total, 2], labels = total, pch = 24, col = "black", cex = 1)
text(points_c[lopit, 1], points_c[lopit, 2], labels = lopit,pch = 24, col = "blue", cex = 1)
text(points_c[both, 1], points_c[both, 2], labels = both,pch = 24, col = "red", cex = 1)

prettyplot_overlay(tsne_ir, IR_protCom, fcol = "alloc.noOut", main = "IR-treated", mainCol = paste0(darken(mycol), 30),  outlineCol = paste0(lighten(mycol), 30))
text(points_ir[total, 1], points_ir[total, 2], labels = total, pch = 24, col = "black", cex = 1)
text(points_ir[lopit, 1], points_ir[lopit, 2], labels = lopit,pch = 24, col = "blue", cex = 1)
text(points_ir[both, 1], points_ir[both, 2], labels = both,pch = 24, col = "red", cex = 1)


plot.new()
addLegend(C_protCom, fcol = "alloc.noOut", "topleft", cex = 1.5)
legend("bottomleft", c("significant in total proteome", "significant in LOPIT", "significant in both"), cex=1.5, col = "black", fill=c("black", "blue", "red"), bty = "n")



```
"Signaling by Rho GTPases"
```{r rho-gtp, fig.height=5, fig.width=15}

total <- tp_res[which(tp_res$Description == "Signaling by Rho GTPases"),]$geneID %>% strsplit(split = "\\/") %>% unlist()

lopit <- lopit_res[which(lopit_res$Description == "RHO GTPase cycle"),]$geneID %>% strsplit(split = "\\/") %>% unlist()

#both <- intersect(lopit, total)


# # Make extra tsne object for labelling - need row names as gene names 
# points_c <- tsne_c
# points_ir <- tsne_ir
# rownames(points_c) <- fData(C_protCom)$gene_name
# rownames(points_ir) <- fData(IR_protCom)$gene_name

par(mfrow = c(1,3))
prettyplot_overlay(tsne_c, C_protCom, fcol = "alloc.noOut", main = "Control", mainCol = paste0(darken(mycol), 30),  outlineCol = paste0(lighten(mycol), 30))
#text(points_c[total, 1], points_c[total, 2], labels = total, pch = 24, col = "black", cex = 1)
text(points_c[lopit, 1], points_c[lopit, 2], labels = lopit,pch = 24, col = "blue", cex = 1)
#text(points_c[both, 1], points_c[both, 2], labels = both,pch = 24, col = "red", cex = 1)

prettyplot_overlay(tsne_ir, IR_protCom, fcol = "alloc.noOut", main = "IR-treated", mainCol = paste0(darken(mycol), 30),  outlineCol = paste0(lighten(mycol), 30))
#text(points_ir[total, 1], points_ir[total, 2], labels = total, pch = 24, col = "black", cex = 1)
text(points_ir[lopit, 1], points_ir[lopit, 2], labels = lopit,pch = 24, col = "blue", cex = 1)
#text(points_ir[both, 1], points_ir[both, 2], labels = both,pch = 24, col = "red", cex = 1)


plot.new()
addLegend(C_protCom, fcol = "alloc.noOut", "topleft", cex = 1.5)
legend("bottomleft", c("significant in total proteome", "significant in LOPIT", "significant in both"), cex=1.5, col = "black", fill=c("black", "blue", "red"), bty = "n")


```
"Mitotic Spindle Checkpoint|Mitotic Metaphase and Anaphase"
```{r mitotic-cent-prots, fig.height=5, fig.width=15}

total <- tp_res[grepl("Mitotic Spindle Checkpoint|Mitotic Metaphase and Anaphase", tp_res$Description),]$geneID %>% strsplit(split = "\\/") %>% unlist()

total <- total[!duplicated(total)]
total <- intersect(total, fData(C_protCom)$gene_name)

lopit <- lopit_res[grepl("Recruitment of mitotic centrosome proteins and complexes|Recruitment of NuMA to mitotic centrosomes", lopit_res$Description),]$geneID %>% strsplit(split = "\\/") %>% unlist()
lopit <- intersect(lopit, fData(C_protCom)$gene_name)

both <- intersect(lopit, total)


# # Make extra tsne object for labelling - need row names as gene names 
points_c <- tsne_c
points_ir <- tsne_ir
rownames(points_c) <- fData(C_protCom)$gene_name
rownames(points_ir) <- fData(IR_protCom)$gene_name

par(mfrow = c(1,3))
prettyplot_overlay(tsne_c, C_protCom, fcol = "alloc.noOut", main = "Control", mainCol = paste0(darken(mycol), 30),  outlineCol = paste0(lighten(mycol), 30))
text(points_c[total, 1], points_c[total, 2], labels = total, pch = 24, col = "black", cex = 1)
text(points_c[lopit, 1], points_c[lopit, 2], labels = lopit, pch = 24, col = "blue", cex = 1)
text(points_c[both, 1], points_c[both, 2], labels = both, pch = 24, col = "red", cex = 1)

prettyplot_overlay(tsne_ir, IR_protCom, fcol = "alloc.noOut", main = "IR-treated", mainCol = paste0(darken(mycol), 30),  outlineCol = paste0(lighten(mycol), 30))
text(points_ir[total, 1], points_ir[total, 2], labels = total, pch = 24, col = "black", cex = 1)
text(points_ir[lopit, 1], points_ir[lopit, 2], labels = lopit,pch = 24, col = "blue", cex = 1)
text(points_ir[both, 1], points_ir[both, 2], labels = both,pch = 24, col = "red", cex = 1)


plot.new()
addLegend(C_protCom, fcol = "alloc.noOut", "topleft", cex = 1.5)
legend("bottomleft", c("significant in total proteome", "significant in LOPIT", "significant in both"), cex=1.5, col = "black", fill=c("black", "blue", "red"), bty = "n")



```
"Iron uptake and transport"
```{r iron-met-prots, fig.height=5, fig.width=15}

# Extract the proteins from enrichment data in total prot and LOPIT
iron <- lopit_res[grepl("Iron uptake and transport", lopit_res$Description),]$geneID %>% strsplit(split = "\\/") %>% unlist()
ferroptosis <- c("AIFM2", "FTL", "FTH1", "TFRC", "SLC7A11", "TMEM164", "GPX4")

lopit_LD <- read.csv("./csv/LOPIT_eFDR0.05/diffloc_hits.csv") %>% select(gene_name)
ferrop_move <- intersect(lopit_LD$gene_name, ferroptosis)


par(mfrow = c(1,3))
prettyplot_overlay(tsne_c, C_protCom, fcol = "alloc.noOut", main = "Control", mainCol = paste0(darken(mycol), 30),  outlineCol = paste0(lighten(mycol), 30))
text(points_c[ferroptosis, 1], points_c[ferroptosis, 2], labels = ferroptosis, pch = 24, col = "black", cex = 1)
text(points_c[iron, 1], points_c[iron, 2], labels = iron, pch = 24, col = "blue", cex = 1)
text(points_c[ferrop_move, 1], points_c[ferrop_move, 2], labels = ferrop_move, pch = 24, col = "red", cex = 1)

prettyplot_overlay(tsne_ir, IR_protCom, fcol = "alloc.noOut", main = "IR-treated", mainCol = paste0(darken(mycol), 30),  outlineCol = paste0(lighten(mycol), 30))
text(points_ir[ferroptosis, 1], points_ir[ferroptosis, 2], labels = ferroptosis, pch = 24, col = "black", cex = 1)
text(points_ir[iron, 1], points_ir[iron, 2], labels = iron, pch = 24, col = "blue", cex = 1)
text(points_ir[ferrop_move, 1], points_ir[ferrop_move, 2], labels = ferrop_move, pch = 24, col = "red", cex = 1)


plot.new()
addLegend(C_protCom, fcol = "alloc.noOut", "topleft", cex = 1.5)
legend("bottomleft", c("significant in total proteome", "significant in LOPIT", "significant in both"), cex=1.5, col = "black", fill=c("black", "blue", "red"), bty = "n")


```

Ferroptosis-related proteins

```{r iron-met-prots-gg, fig.width=15, fig.height=7.5}

# Extract the proteins from enrichment data in total prot and LOPIT
iron <- lopit_res[grepl("Iron uptake and transport", lopit_res$Description),]$geneID %>% strsplit(split = "\\/") %>% unlist()
ferroptosis <- c("AIFM2", "FTL", "FTH1", "TFRC", "SLC7A11", "TMEM164", "GPX4")

lopit_LD <- read.csv("./csv/LOPIT_eFDR0.05/diffloc_hits.csv") %>% select(gene_name)
ferrop_move <- intersect(lopit_LD$gene_name, ferroptosis)

ferrop_stab <- setdiff(ferroptosis, ferrop_move)
iron <- setdiff(iron, ferroptosis)

ferrop_stab <- paste(ferrop_stab, collapse='|')
ferrop_move <- paste(ferrop_move, collapse='|')
iron <- paste(iron, collapse='|')

# Create ggplot dataframes
points_c <- as.data.frame(points_c)
points_ir <- as.data.frame(points_ir)
points_c$condition <- "Control"
points_ir$condition <- "IR-treated"
points_c <- rownames_to_column(as.data.frame(points_c), var = "genes")
points_ir <- rownames_to_column(as.data.frame(points_ir), var = "genes")
gg <- rbind(points_c, points_ir)


gg <- gg %>% mutate(POI = case_when(grepl(ferrop_move, gg$genes) ~ "GO: ferroptosis (DL)",
                                    grepl(ferrop_stab, gg$genes) ~ "GO: ferroptosis (stable)",
                                    #grepl(iron, gg$genes) ~ "GO: iron uptake and transport (DL)",
                                    TRUE ~ "NA"))


gg$bandle.class <- fData(C_protCom)$alloc.noOut[match(fData(C_protCom)$gene_name, gg$genes)]
gg$bandle.prob <- fData(C_protCom)$bandle.probability[match(fData(C_protCom)$gene_name, gg$genes)]
gg$markers <- fData(C_protCom)$markers[match(fData(C_protCom)$gene_name, gg$genes)]

gg <- gg %>% mutate(all.class = coalesce(bandle.class, markers))

gg[which(gg$all.class == "unknown"),]$bandle.prob <- 1 - gg[which(gg$all.class == "unknown"),]$bandle.prob


set.seed(15)
ggplot(gg, aes(x = `Dimension 1`, y = `Dimension 2`, size = bandle.prob))+
  geom_point(aes(color = all.class), alpha = 0.3, stroke = 0, show.legend = F)+
  geom_point(data = gg %>% filter(gg$POI != "NA"), aes(fill = POI), shape = 23, size = 4, colour = "white")+
  scale_size_continuous(range = c(0.1, 4.5), guide = "none")+
  scale_color_manual(values = mycol)+
  scale_fill_manual(values = c("red", "black"))+
  facet_wrap(~condition)+
  ggnewscale::new_scale_colour()+
  geom_label_repel(data = gg %>% filter(gg$POI != "NA"),
                   aes(label = genes, colour = POI),
                   size = 4.5,
                   # nudge_y = 8,
                   # nudge_x = -2,
                   max.overlaps = 10,
                     box.padding = unit(.2, "lines"),
                     point.padding = unit(2, "lines"),
                     show.legend = F)+
  scale_color_manual(values = c("red", "black"))+
  theme_bw()+
      theme(strip.text.x = element_text(size = 22),
          axis.text = element_text(size = 15),
          axis.title = element_text(size = 20),
          legend.text = element_text(size = 15),
          legend.position = "bottom",
          #plot.margin =  margin(0,12,0,5, "cm"),
          panel.background = element_rect(color = "grey", fill = "white"),
          strip.background = element_rect(color="grey", fill="white"),
          strip.text = element_text(color = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank())
  

```

<br>

## Customisable violin plots
```{r mcmc-plots-ferropt, fig.height = 9, fig.width=8}



mcmc_df <- function (params, fname, cond = 1, n = 1, gname= gname, sample = sample) 
{
  stopifnot(is(params, "bandleParams"))
  stopifnot(is(fname, "character"))
  Organelle <- Probability <- NULL
  ch <- params@chains[[n]]
  dfr <- as.data.frame(ch@nicheProb[[cond]][fname, , ])
  dfr_long <- data.frame(Organelle = rep(names(dfr), each = nrow(dfr)), 
    Probability = unlist(dfr, use.names = FALSE), Protein = fname, Sample = sample, gene_name = gname, chain = n, row.names = NULL, 
    stringsAsFactors = FALSE)


}


# Get all chain info

mcmc_c <- list()
mcmc_ir <- list()
prots <- c("Q9BRQ8", "P02786", "P02792", "P02794")
gene_name <- c("AIFM2", "TFRC", "FTL", "FTH1")

for(q in 1:length(prots)){
  
  for(n in seq_along(1:4)){
    
    mcmc_c[[length(mcmc_c)+1]] <- mcmc_df(bandleres_12hr, fname = prots[q], gname = gene_name[q], cond = 1, n = n, sample = "Control")
    mcmc_ir[[length(mcmc_c)+1]] <- mcmc_df(bandleres_12hr, fname = prots[q], gname = gene_name[q], cond = 2, n = n, sample = "IR-treated")
    
  }
}

mcdf <- rbind(do.call(rbind, mcmc_c), do.call(rbind, mcmc_ir))



ggplot(mcdf, aes(Organelle, Probability), width = Probability) + 
    geom_violin(aes(fill = Organelle, colour = Organelle), alpha = 0.5, scale = "width", bw = 0.05) +
    geom_jitter(aes(color = Organelle), height = 0.01, width = 0.1, size = 0.2) +
  scale_fill_manual(values = mycol)+
  facet_grid(gene_name~Sample) + theme_light() + scale_color_manual(values = mycol) + 
    theme(text = element_text(size = 15), 
          strip.text.x = element_text(size = 20),
          strip.text.y = element_text(size = 18),
          axis.text.x = element_text(angle = 45, hjust = 1, size = 15), 
          axis.title.y = element_text(size = 20),
          axis.title.x = element_blank(),
          panel.background = element_rect(color = "grey", fill = "white"),
          strip.background = element_rect(color="grey", fill="white"),
          strip.text = element_text(color = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),) + 
  ylab("Membership Probability")  + theme(legend.position = "none")



```


```{r mcmc-plots-ferropt-stab, fig.height = 6, fig.width=5}

# Get all chain info

mcmc_c <- list()
mcmc_ir <- list()
prots <- c("P36969", "Q9UPY5", "Q5U3C3")
gene_name <- c("GPX4", "SLC7A11", "TMEM164")

for(q in 1:length(prots)){
  
  for(n in seq_along(1:4)){
    
    mcmc_c[[length(mcmc_c)+1]] <- mcmc_df(bandleres_12hr, fname = prots[q], gname = gene_name[q], cond = 1, n = n, sample = "Control")
    mcmc_ir[[length(mcmc_c)+1]] <- mcmc_df(bandleres_12hr, fname = prots[q], gname = gene_name[q], cond = 2, n = n, sample = "IR-treated")
    
  }
}

mcdf <- rbind(do.call(rbind, mcmc_c), do.call(rbind, mcmc_ir))



ggplot(mcdf, aes(Organelle, Probability), width = Probability) + 
    geom_violin(aes(fill = Organelle), alpha = 0.5, scale = "width", bw = 0.05) +
    geom_jitter(aes(color = Organelle), height = 0.01, width = 0.1, size = 0.2) +
  scale_fill_manual(values = mycol)+
  facet_grid(gene_name~Sample) + theme_light() + scale_color_manual(values = mycol) + 
    theme(text = element_text(size = 15), 
          axis.text.x = element_text(angle = 45, hjust = 1, size = 6), 
          axis.title.x = element_blank(),
          panel.background = element_rect(color = "grey", fill = "white"),
          strip.background = element_rect(color="grey", fill="white"),
          strip.text = element_text(color = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),) + 
  ylab("Membership Probability")  + theme(legend.position = "none")



```


```{r mcmc-plots-iron, fig.height = 6, fig.width=5}


iron <- lopit_res[grepl("Iron uptake and transport", lopit_res$Description),]$geneID %>% strsplit(split = "\\/") %>% unlist()

iron <- setdiff(iron, ferroptosis)

# Get all chain info

mcmc_c <- list()
mcmc_ir <- list()
prots <- rownames(fData(C_protCom))[match(iron, fData(C_protCom)$gene_name)]
gene_name <- iron

for(q in 1:length(prots)){
  
  for(n in seq_along(1:4)){
    
    mcmc_c[[length(mcmc_c)+1]] <- mcmc_df(bandleres_12hr, fname = prots[q], gname = gene_name[q], cond = 1, n = n, sample = "Control")
    mcmc_ir[[length(mcmc_c)+1]] <- mcmc_df(bandleres_12hr, fname = prots[q], gname = gene_name[q], cond = 2, n = n, sample = "IR-treated")
    
  }
}

mcdf <- rbind(do.call(rbind, mcmc_c), do.call(rbind, mcmc_ir))



ggplot(mcdf, aes(Organelle, Probability), width = Probability) + 
    geom_violin(aes(fill = Organelle), alpha = 0.5, scale = "width", bw = 0.05) +
    geom_jitter(aes(color = Organelle), height = 0.01, width = 0.1, size = 0.2) +
  scale_fill_manual(values = mycol)+
  facet_grid(gene_name~Sample) + theme_light() + scale_color_manual(values = mycol) + 
    theme(text = element_text(size = 15), 
          axis.text.x = element_text(angle = 45, hjust = 1, size = 6), 
          axis.title.x = element_blank(),
          panel.background = element_rect(color = "grey", fill = "white"),
          strip.background = element_rect(color="grey", fill="white"),
          strip.text = element_text(color = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),) + 
  ylab("Membership Probability")  + theme(legend.position = "none")



```

<br>

## Plot the intensity profiles of proteins of interest (ferroptosis)

```{r poi-profs-aifm2, fig.width=14, fig.height=2.5}

# Extract expression data and merge with relevant fData 

p_c <- pData(C_protCom)
p_c$spinID <- paste0("R", pData(C_protCom)$Replicate, "_", pData(C_protCom)$Sample_name)
p_c <- rownames_to_column(p_c, var = "channel")

e_c <- exprs(C_protCom)
colnames(e_c) <- p_c$spinID[match(colnames(e_c), p_c$channel)]
e_c <- melt(e_c)
colnames(e_c) <- c("accession", "channel", "intensity")
e_c$markers <- fData(C_protCom)$markers[match(e_c$accession, rownames(C_protCom))]
e_c$bandle.class <- fData(C_protCom)$alloc.noOut[match(e_c$accession, rownames(C_protCom))]
e_c$bandle.pred <- fData(C_protCom)$bandle.allocation[match(e_c$accession, rownames(C_protCom))]
e_c$bandle.prob <- fData(C_protCom)$bandle.probability[match(e_c$accession, rownames(C_protCom))]
e_c$condition <- "control"
e_c$gene_name <- fData(C_protCom)$gene_name[match(e_c$accession, rownames(C_protCom))]


p_ir <- pData(IR_protCom)
p_ir$spinID <- paste0("R", pData(IR_protCom)$Replicate, "_", pData(IR_protCom)$Sample_name)
p_ir <- rownames_to_column(p_ir, var = "channel")

e_ir <- exprs(IR_protCom)
colnames(e_ir) <- p_ir$spinID[match(colnames(e_ir), p_ir$channel)]
e_ir <- melt(e_ir)
colnames(e_ir) <- c("accession", "channel", "intensity")
e_ir$markers <- fData(IR_protCom)$markers[match(e_ir$accession, rownames(IR_protCom))]
e_ir$bandle.class <- fData(IR_protCom)$alloc.noOut[match(e_ir$accession, rownames(IR_protCom))]
e_ir$bandle.pred <- fData(IR_protCom)$bandle.allocation[match(e_ir$accession, rownames(IR_protCom))]
e_ir$bandle.prob <- fData(IR_protCom)$bandle.probability[match(e_ir$accession, rownames(IR_protCom))]
e_ir$condition <- "IR-treated"
e_ir$gene_name <- fData(IR_protCom)$gene_name[match(e_ir$accession, rownames(IR_protCom))]

prof_dat <- rbind(e_c, e_ir)




prof_dat <- prof_dat %>% mutate(POI = case_when(grepl("AIFM2|TFRC|FTL|FTH1", prof_dat$gene_name) ~ "GO: ferroptosis (DL)",
                                TRUE ~ "NA"))


prof_dat$channel <- factor(prof_dat$channel, levels = unique(prof_dat$channel))

# Create colour vector with assigned marker colours 
markers <- unique(prof_dat$markers)[order(unique(prof_dat$markers))]
markers <- factor(markers, levels = markers) #order markers
cols <- mycol
names(cols) <- markers


ggplot(data = prof_dat, aes(x = channel, y = intensity, group = accession))+
  #geom_point()+
  geom_line(data = prof_dat %>% filter(markers == unique(prof_dat[which(prof_dat$gene_name == "AIFM2"),]$bandle.pred)[1]), aes(color = markers, group = accession), alpha = 0.25, size = 1)+
  geom_line(data = prof_dat %>% filter(markers == unique(prof_dat[which(prof_dat$gene_name == "AIFM2"),]$bandle.pred)[2]), aes(color = markers, group = accession), alpha = 0.25, size = 1)+
  geom_line(data = prof_dat %>% filter(gene_name == "AIFM2"), color = "grey20", alpha = 0.8, size = 2)+
  facet_grid("AIFM2" ~ condition)+
  ylim(0,0.6)+
  ylab("")+
  xlab("")+
  scale_color_manual(values = cols)+ 
    theme(text = element_text(size = 20), 
          axis.text.x = element_blank(), #element_text(angle = 45, hjust = 1, size = 12), 
          axis.title.x = element_blank(),
          panel.background = element_rect(color = "grey", fill = "white", size = 1.5),
          strip.background = element_rect(color="grey", fill="white", size = 1.5),
          strip.text.y = element_text(color = "black", size =30),
          strip.text.x = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          legend.position = "none") 


```

```{r poi-profs-tfrc, fig.width=14, fig.height=4}

ggplot(data = prof_dat, aes(x = channel, y = intensity, group = accession))+
  #geom_point()+
  geom_line(data = prof_dat %>% filter(markers == unique(prof_dat[which(prof_dat$gene_name == "TFRC"),]$bandle.pred)[1]), aes(color = markers, group = accession), alpha = 0.25, size = 1)+
  geom_line(data = prof_dat %>% filter(markers == unique(prof_dat[which(prof_dat$gene_name == "TFRC"),]$bandle.pred)[2]), aes(color = markers, group = accession), alpha = 0.25, size = 1)+
  geom_line(data = prof_dat %>% filter(gene_name == "TFRC"), color = "grey20", alpha = 0.8, size = 2)+
  facet_grid("TFRC" ~ condition)+
  ylim(0,0.6)+
  ylab("")+
  xlab("")+
  scale_color_manual(values = cols)+ 
    theme(text = element_text(size = 20), 
          axis.text.x = element_text(angle = 45, hjust = 1, size = 15), 
          #axis.title.x = element_blank(),
          panel.background = element_rect(color = "grey", fill = "white", size = 1.5),
          strip.background = element_rect(color="grey", fill="white", size = 1.5),
          strip.text.y = element_text(color = "black", size = 30),
          strip.text.x = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          legend.position = "none") 




```

```{r poi-profs-fth1, fig.width=14, fig.height=3}

ggplot(data = prof_dat, aes(x = channel, y = intensity, group = accession))+
  #geom_point()+
  geom_line(data = prof_dat %>% filter(markers == unique(prof_dat[which(prof_dat$gene_name == "FTH1"),]$bandle.pred)[1]), aes(color = markers, group = accession), alpha = 0.25, size = 1)+
  geom_line(data = prof_dat %>% filter(markers == unique(prof_dat[which(prof_dat$gene_name == "FTH1"),]$bandle.pred)[2]), aes(color = markers, group = accession), alpha = 0.25, size = 1)+
  geom_line(data = prof_dat %>% filter(gene_name == "FTH1"), color = "grey20", alpha = 0.8, size = 2)+
  facet_grid("FTH1" ~ condition)+
  ylim(0,0.6)+
  ylab("")+
  xlab("")+
  scale_color_manual(values = cols)+ 
    theme(text = element_text(size = 20), 
          axis.text.x = element_blank(), #element_text(angle = 45, hjust = 1, size = 12), 
          axis.title.x = element_blank(),
          panel.background = element_rect(color = "grey", fill = "white", size = 1.5),
          strip.background = element_rect(color="grey", fill="white", size = 1.5),
          strip.text.y = element_text(color = "black", size = 30),
          strip.text.x = element_text(color = "black", size = 30),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          legend.position = "none") 




```

```{r poi-profs-ftl, fig.width=14, fig.height=2.5}

ggplot(data = prof_dat, aes(x = channel, y = intensity, group = accession))+
  #geom_point()+
  geom_line(data = prof_dat %>% filter(markers == unique(prof_dat[which(prof_dat$gene_name == "FTL"),]$bandle.pred)[1]), aes(color = markers, group = accession), alpha = 0.25, size = 1)+
  geom_line(data = prof_dat %>% filter(markers == unique(prof_dat[which(prof_dat$gene_name == "FTL"),]$bandle.pred)[2]), aes(color = markers, group = accession), alpha = 0.25, size = 1)+
  geom_line(data = prof_dat %>% filter(gene_name == "FTL"), color = "grey20", alpha = 0.8, size = 2)+
  facet_grid("FTL" ~ condition)+
  ylim(0,0.6)+
  ylab("")+
  xlab("")+
  scale_color_manual(values = cols)+ 
    theme(text = element_text(size = 20), 
          axis.text.x = element_blank(), #element_text(angle = 45, hjust = 1, size = 12), 
          axis.title.x = element_blank(),
          panel.background = element_rect(color = "grey", fill = "white", size = 1.5),
          strip.background = element_rect(color="grey", fill="white", size = 1.5),
          strip.text.y = element_text(color = "black", size = 30),
          strip.text.x = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          legend.position = "none") 




```

Demonstrating exocyst complex moving to PM as part of SNARE-mediated fusion https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4589602/. https://ciliajournal.biomedcentral.com/articles/10.1186/s13630-017-0052-x

```{r exo-prots-gg, fig.width=15, fig.height=7.5}

mem_traf <- lopit_res[grepl("VxPx cargo-targeting to cilium", lopit_res$Description),]$geneID %>% strsplit(split = "\\/") %>% unlist()

mem_traf_move <- intersect(lopit_LD$gene_name, mem_traf)

mem_traf_move <- paste(mem_traf_move, collapse='|')


gg_mem_traf <- gg %>% mutate(POI = case_when(grepl(mem_traf_move, gg$genes) ~ "GO: Membrane trafficking (DL)",
                                    #grepl(iron, gg$genes) ~ "GO: iron uptake and transport (DL)",
                                    TRUE ~ "NA"))


gg_mem_traf  <- gg_mem_traf  %>%
  left_join(., fData(C_protCom) %>%
              select(gene_name, bandle.differential.localisation) %>%
              rename("genes" = gene_name), by = "genes")


set.seed(15)
ggplot(gg_mem_traf , aes(x = `Dimension 1`, y = `Dimension 2`, size = bandle.prob))+
  geom_point(aes(color = all.class), alpha = 0.3, stroke = 0, show.legend = F)+
  geom_point(data = gg_mem_traf  %>% filter(grepl(mem_traf_move , genes)), aes(fill = bandle.differential.localisation), shape = 23, size = 4, colour = "white")+
  scale_size_continuous(range = c(0.1, 4.5), guide = "none")+
  scale_color_manual(values = mycol)+
  #scale_fill_manual(values = c("red", "black"))+
  facet_wrap(~condition)+
  ggnewscale::new_scale_colour()+
  geom_label_repel(data = gg_mem_traf  %>%
                     filter(grepl(mem_traf_move , genes)),
                   aes(label = genes, colour = bandle.differential.localisation),
                   size = 4.5,
                   # nudge_y = 8,
                   # nudge_x = -2,
                   max.overlaps = 20,
                     box.padding = unit(.2, "lines"),
                     point.padding = unit(2, "lines"),
                     show.legend = F)+
  theme_bw()+
      theme(strip.text.x = element_text(size = 22),
          axis.text = element_text(size = 15),
          axis.title = element_text(size = 20),
          legend.text = element_text(size = 10),
          legend.position = "bottom",
          #plot.margin =  margin(0,12,0,5, "cm"),
          panel.background = element_rect(color = "grey", fill = "white"),
          strip.background = element_rect(color="grey", fill="white"),
          strip.text = element_text(color = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank())
  

```

```{r mcmc-plots-exo, fig.height = 12, fig.width=5}


iron <- lopit_res[grepl("VxPx cargo-targeting to cilium", lopit_res$Description),]$geneID %>% strsplit(split = "\\/") %>% unlist()

iron <- setdiff(iron, ferroptosis)

# Get all chain info

mcmc_c <- list()
mcmc_ir <- list()
prots <- rownames(fData(C_protCom))[match(iron, fData(C_protCom)$gene_name)]
gene_name <- iron

for(q in 1:length(prots)){
  
  for(n in seq_along(1:4)){
    
    mcmc_c[[length(mcmc_c)+1]] <- mcmc_df(bandleres_12hr, fname = prots[q], gname = gene_name[q], cond = 1, n = n, sample = "Control")
    mcmc_ir[[length(mcmc_c)+1]] <- mcmc_df(bandleres_12hr, fname = prots[q], gname = gene_name[q], cond = 2, n = n, sample = "IR-treated")
    
  }
}

mcdf <- rbind(do.call(rbind, mcmc_c), do.call(rbind, mcmc_ir))



ggplot(mcdf, aes(Organelle, Probability), width = Probability) + 
    geom_violin(aes(fill = Organelle), alpha = 0.5, scale = "width", bw = 0.05) +
    geom_jitter(aes(color = Organelle), height = 0.01, width = 0.1, size = 0.2) +
  scale_fill_manual(values = mycol)+
  facet_grid(gene_name~Sample) + theme_light() + scale_color_manual(values = mycol) + 
    theme(text = element_text(size = 15), 
          axis.text.x = element_text(angle = 45, hjust = 1, size = 6), 
          axis.title.x = element_blank(),
          panel.background = element_rect(color = "grey", fill = "white"),
          strip.background = element_rect(color="grey", fill="white"),
          strip.text = element_text(color = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),) + 
  ylab("Membership Probability")  + theme(legend.position = "none")



```

Demonstrate golgi-vesicle biogenesis

```{r golg-ves-prots-gg, fig.width=15, fig.height=7.5}

mem_traf <- lopit_res[grepl("Golgi Associated Vesicle Biogenesis", lopit_res$Description),]$geneID %>% strsplit(split = "\\/") %>% unlist()

mem_traf_move <- intersect(lopit_LD$gene_name, mem_traf)

mem_traf_move <- paste(mem_traf_move, collapse='|')


gg_mem_traf <- gg %>% mutate(POI = case_when(grepl(mem_traf_move, gg$genes) ~ "GO: Membrane trafficking (DL)",
                                    #grepl(iron, gg$genes) ~ "GO: iron uptake and transport (DL)",
                                    TRUE ~ "NA"))


gg_mem_traf  <- gg_mem_traf  %>%
  left_join(., fData(C_protCom) %>%
              select(gene_name, bandle.differential.localisation) %>%
              rename("genes" = gene_name), by = "genes")


set.seed(15)
ggplot(gg_mem_traf , aes(x = `Dimension 1`, y = `Dimension 2`, size = bandle.prob))+
  geom_point(aes(color = all.class), alpha = 0.3, stroke = 0, show.legend = F)+
  geom_point(data = gg_mem_traf  %>% filter(grepl(mem_traf_move , genes)), aes(fill = bandle.differential.localisation), shape = 23, size = 4, colour = "white")+
  scale_size_continuous(range = c(0.1, 4.5), guide = "none")+
  scale_color_manual(values = mycol)+
  #scale_fill_manual(values = c("red", "black"))+
  facet_wrap(~condition)+
  ggnewscale::new_scale_colour()+
  geom_label_repel(data = gg_mem_traf  %>%
                     filter(grepl(mem_traf_move , genes)),
                   aes(label = genes, colour = bandle.differential.localisation),
                   size = 4.5,
                   # nudge_y = 8,
                   # nudge_x = -2,
                   max.overlaps = 20,
                     box.padding = unit(.2, "lines"),
                     point.padding = unit(2, "lines"),
                     show.legend = F)+
  theme_bw()+
      theme(strip.text.x = element_text(size = 22),
          axis.text = element_text(size = 15),
          axis.title = element_text(size = 20),
          legend.text = element_text(size = 5),
          legend.position = "bottom",
          #plot.margin =  margin(0,12,0,5, "cm"),
          panel.background = element_rect(color = "grey", fill = "white"),
          strip.background = element_rect(color="grey", fill="white"),
          strip.text = element_text(color = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank())
  

```

```{r mcmc-plots-golgi-ves, fig.height = 12, fig.width=5}


iron <- lopit_res[grepl("Golgi Associated Vesicle Biogenesis", lopit_res$Description),]$geneID %>% strsplit(split = "\\/") %>% unlist()

iron <- setdiff(iron, ferroptosis)

# Get all chain info

mcmc_c <- list()
mcmc_ir <- list()
prots <- rownames(fData(C_protCom))[match(iron, fData(C_protCom)$gene_name)]
gene_name <- iron

for(q in 1:length(prots)){
  
  for(n in seq_along(1:4)){
    
    mcmc_c[[length(mcmc_c)+1]] <- mcmc_df(bandleres_12hr, fname = prots[q], gname = gene_name[q], cond = 1, n = n, sample = "Control")
    mcmc_ir[[length(mcmc_c)+1]] <- mcmc_df(bandleres_12hr, fname = prots[q], gname = gene_name[q], cond = 2, n = n, sample = "IR-treated")
    
  }
}

mcdf <- rbind(do.call(rbind, mcmc_c), do.call(rbind, mcmc_ir))



ggplot(mcdf, aes(Organelle, Probability), width = Probability) + 
    geom_violin(aes(fill = Organelle), alpha = 0.5, scale = "width", bw = 0.05) +
    geom_jitter(aes(color = Organelle), height = 0.01, width = 0.1, size = 0.2) +
  scale_fill_manual(values = mycol)+
  facet_grid(gene_name~Sample) + theme_light() + scale_color_manual(values = mycol) + 
    theme(text = element_text(size = 15), 
          axis.text.x = element_text(angle = 45, hjust = 1, size = 6), 
          axis.title.x = element_blank(),
          panel.background = element_rect(color = "grey", fill = "white"),
          strip.background = element_rect(color="grey", fill="white"),
          strip.text = element_text(color = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),) + 
  ylab("Membership Probability")  + theme(legend.position = "none")



```


```{r}
sessionInfo()
```